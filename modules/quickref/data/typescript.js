/**
 * TypeScript 快速参考数据
 * 基于 quickref.me 的 TypeScript 参考内容
 */

const TYPESCRIPT_CHEATSHEET = {
    id: 'typescript',
    title: 'TypeScript',
    description: 'TypeScript 是 JavaScript 的超集，添加了静态类型定义',
    icon: '🔷',
    category: 'frontend',
    sections: [
        {
            title: '基础类型',
            items: [
                {
                    title: '基本类型',
                    description: 'TypeScript的基本数据类型',
                    code: '// 基本类型\nlet isDone: boolean = false;\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet color: string = "blue";\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${fullName}.`;\n\n// 数组\nlet list: number[] = [1, 2, 3];\nlet list2: Array<number> = [1, 2, 3];\n\n// 元组\nlet x: [string, number];\nx = ["hello", 10]; // OK\n// x = [10, "hello"]; // Error\n\n// 枚举\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c: Color = Color.Green;\n\n// 字符串枚举\nenum Direction {\n    Up = "UP",\n    Down = "DOWN",\n    Left = "LEFT",\n    Right = "RIGHT",\n}\n\n// Any类型\nlet notSure: any = 4;\nnotSure = "maybe a string instead";\nnotSure = false; // okay, definitely a boolean\n\n// Void类型\nfunction warnUser(): void {\n    console.log("This is my warning message");\n}\n\n// Null和Undefined\nlet u: undefined = undefined;\nlet n: null = null;\n\n// Never类型\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// Object类型\nlet obj: object = { name: "Alice", age: 25 };'
                },
                {
                    title: '类型断言',
                    description: '类型断言和类型守卫',
                    code: '// 类型断言\nlet someValue: any = "this is a string";\nlet strLength: number = (<string>someValue).length;\n// 或者\nlet strLength2: number = (someValue as string).length;\n\n// 类型守卫\nfunction isString(value: any): value is string {\n    return typeof value === "string";\n}\n\nfunction example(value: string | number) {\n    if (isString(value)) {\n        // 在这个块中，value被推断为string类型\n        console.log(value.toUpperCase());\n    } else {\n        // 在这个块中，value被推断为number类型\n        console.log(value.toFixed(2));\n    }\n}\n\n// typeof类型守卫\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n    throw new Error(`Expected string or number, got \'${padding}\'.`);\n}\n\n// instanceof类型守卫\nclass Bird {\n    fly() {\n        console.log("bird fly");\n    }\n    layEggs() {\n        console.log("bird lay eggs");\n    }\n}\n\nclass Fish {\n    swim() {\n        console.log("fish swim");\n    }\n    layEggs() {\n        console.log("fish lay eggs");\n    }\n}\n\nfunction getRandomPet(): Fish | Bird {\n    return Math.random() > 0.5 ? new Bird() : new Fish();\n}\n\nlet pet = getRandomPet();\nif (pet instanceof Bird) {\n    pet.fly();\n}\nif (pet instanceof Fish) {\n    pet.swim();\n}'
                },
                {
                    title: '联合类型和交叉类型',
                    description: '联合类型和交叉类型的使用',
                    code: '// 联合类型\nfunction padLeft(value: string, padding: string | number) {\n    if (typeof padding === "number") {\n        return Array(padding + 1).join(" ") + value;\n    }\n    if (typeof padding === "string") {\n        return padding + value;\n    }\n}\n\n// 字面量类型\ntype Easing = "ease-in" | "ease-out" | "ease-in-out";\n\nclass UIElement {\n    animate(dx: number, dy: number, easing: Easing) {\n        if (easing === "ease-in") {\n            // ...\n        } else if (easing === "ease-out") {\n            // ...\n        } else if (easing === "ease-in-out") {\n            // ...\n        }\n    }\n}\n\n// 数字字面量类型\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n    return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\n// 交叉类型\ninterface ErrorHandling {\n    success: boolean;\n    error?: { message: string };\n}\n\ninterface ArtworksData {\n    artworks: { title: string }[];\n}\n\ninterface ArtistsData {\n    artists: { name: string }[];\n}\n\n// 这些接口被合并为一个类型\ntype ArtworksResponse = ArtworksData & ErrorHandling;\ntype ArtistsResponse = ArtistsData & ErrorHandling;\n\nconst handleArtistsResponse = (response: ArtistsResponse) => {\n    if (response.error) {\n        console.error(response.error.message);\n        return;\n    }\n    console.log(response.artists);\n};\n\n// 混合类型\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = function (start: number) { } as Counter;\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}'
                }
            ]
        },
        {
            title: '接口',
            items: [
                {
                    title: '接口定义',
                    description: '接口的基本定义和使用',
                    code: '// 基本接口\ninterface LabeledValue {\n    label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n    console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: "Size 10 Object" };\nprintLabel(myObj);\n\n// 可选属性\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    let newSquare = { color: "white", area: 100 };\n    if (config.color) {\n        newSquare.color = config.color;\n    }\n    if (config.width) {\n        newSquare.area = config.width * config.width;\n    }\n    return newSquare;\n}\n\nlet mySquare = createSquare({ color: "black" });\n\n// 只读属性\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n\nlet p1: Point = { x: 10, y: 20 };\n// p1.x = 5; // error!\n\n// 只读数组\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n// ro[0] = 12; // error!\n// ro.push(5); // error!\n// ro.length = 100; // error!\n\n// 额外的属性检查\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any; // 索引签名\n}\n\n// 函数类型\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    let result = source.search(subString);\n    return result > -1;\n};'
                },
                {
                    title: '可索引类型',
                    description: '数组和字典类型的接口',
                    code: '// 数组索引\ninterface StringArray {\n    [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = ["Bob", "Fred"];\nlet myStr: string = myArray[0];\n\n// 字典索引\ninterface StringDictionary {\n    [index: string]: string;\n}\n\nlet myDict: StringDictionary = {\n    name: "Alice",\n    age: "25" // 必须是string类型\n};\n\n// 混合索引\ninterface NumberOrStringDictionary {\n    [index: string]: number | string;\n    length: number; // 可以，length是number类型\n    name: string; // 可以，name是string类型\n}\n\n// 只读索引\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\n\nlet myArray2: ReadonlyStringArray = ["Alice", "Bob"];\n// myArray2[2] = "Mallory"; // error!\n\n// 类类型\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date = new Date();\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n\n// 构造器签名\ninterface ClockConstructor {\n    new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n    tick(): void;\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n    return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log("beep beep");\n    }\n}\n\nclass AnalogClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log("tick tock");\n    }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);'
                },
                {
                    title: '接口继承',
                    description: '接口的继承和扩展',
                    code: '// 接口继承\ninterface Shape {\n    color: string;\n}\n\ninterface Square extends Shape {\n    sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = "blue";\nsquare.sideLength = 10;\n\n// 多重继承\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square2 = {} as Square;\nsquare2.color = "blue";\nsquare2.sideLength = 10;\nsquare2.penWidth = 5.0;\n\n// 混合类型\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = function (start: number) { return start.toString(); } as Counter;\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n\n// 接口继承类\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\n// 错误："ImageControl"类型缺少"state"属性\n// class ImageControl implements SelectableControl {\n//     private state: any;\n//     select() { }\n// }'
                }
            ]
        },
        {
            title: '类',
            items: [
                {
                    title: '类的基本语法',
                    description: '类的定义、构造函数和方法',
                    code: '// 基本类\nclass Greeter {\n    greeting: string;\n    \n    constructor(message: string) {\n        this.greeting = message;\n    }\n    \n    greet() {\n        return "Hello, " + this.greeting;\n    }\n}\n\nlet greeter = new Greeter("world");\nconsole.log(greeter.greet());\n\n// 继承\nclass Animal {\n    name: string;\n    \n    constructor(theName: string) {\n        this.name = theName;\n    }\n    \n    move(distanceInMeters: number = 0) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n}\n\nclass Snake extends Animal {\n    constructor(name: string) {\n        super(name);\n    }\n    \n    move(distanceInMeters = 5) {\n        console.log("Slithering...");\n        super.move(distanceInMeters);\n    }\n}\n\nclass Horse extends Animal {\n    constructor(name: string) {\n        super(name);\n    }\n    \n    move(distanceInMeters = 45) {\n        console.log("Galloping...");\n        super.move(distanceInMeters);\n    }\n}\n\nlet sam = new Snake("Sammy the Python");\nlet tom: Animal = new Horse("Tommy the Palomino");\n\nsam.move();\ntom.move(34);\n\n// 公共，私有与受保护的修饰符\nclass Animal2 {\n    public name: string; // 公共的（默认）\n    private age: number; // 私有的\n    protected species: string; // 受保护的\n    \n    public constructor(theName: string, theAge: number, theSpecies: string) {\n        this.name = theName;\n        this.age = theAge;\n        this.species = theSpecies;\n    }\n    \n    public move(distanceInMeters: number) {\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\n    }\n    \n    private getAge() {\n        return this.age;\n    }\n    \n    protected getSpecies() {\n        return this.species;\n    }\n}'
                },
                {
                    title: '访问器和静态属性',
                    description: 'getter/setter和静态成员',
                    code: '// 访问器\nclass Employee {\n    private _fullName: string = "";\n    \n    get fullName(): string {\n        return this._fullName;\n    }\n    \n    set fullName(newName: string) {\n        if (newName && newName.length > 0) {\n            this._fullName = newName;\n        } else {\n            console.log("Error: name cannot be empty");\n        }\n    }\n}\n\nlet employee = new Employee();\nemployee.fullName = "Bob Smith";\nif (employee.fullName) {\n    console.log(employee.fullName);\n}\n\n// 静态属性\nclass Grid {\n    static origin = { x: 0, y: 0 };\n    \n    calculateDistanceFromOrigin(point: { x: number; y: number }) {\n        let xDist = point.x - Grid.origin.x;\n        let yDist = point.y - Grid.origin.y;\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    \n    constructor(public scale: number) {}\n}\n\nlet grid1 = new Grid(1.0);\nlet grid2 = new Grid(5.0);\n\nconsole.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nconsole.log(grid2.calculateDistanceFromOrigin({ x: 10, y: 10 }));\n\n// 抽象类\nabstract class Animal3 {\n    abstract makeSound(): void;\n    \n    move(): void {\n        console.log("roaming the earth...");\n    }\n}\n\nclass Dog extends Animal3 {\n    makeSound() {\n        console.log("Woof! Woof!");\n    }\n}\n\nconst dog = new Dog();\ndog.makeSound();\ndog.move();\n\n// 抽象类中的抽象方法\nabstract class Department {\n    constructor(public name: string) {}\n    \n    printName(): void {\n        console.log("Department name: " + this.name);\n    }\n    \n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n    constructor() {\n        super("Accounting and Auditing");\n    }\n    \n    printMeeting(): void {\n        console.log("The Accounting Department meets each Monday at 10am.");\n    }\n    \n    generateReports(): void {\n        console.log("Generating accounting reports...");\n    }\n}\n\nlet department: Department;\n// department = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment();\ndepartment.printName();\ndepartment.printMeeting();\n// department.generateReports(); // 错误: 方法在声明的抽象类中不存在'
                },
                {
                    title: '高级技巧',
                    description: '构造函数类型和类作为接口',
                    code: '// 构造函数\nclass Greeter2 {\n    static standardGreeting = "Hello, there";\n    greeting: string;\n    \n    greet() {\n        if (this.greeting) {\n            return "Hello, " + this.greeting;\n        } else {\n            return Greeter2.standardGreeting;\n        }\n    }\n}\n\nlet greeter1: Greeter2;\ngreeter1 = new Greeter2();\nconsole.log(greeter1.greet());\n\nlet greeterMaker: typeof Greeter2 = Greeter2;\ngreeterMaker.standardGreeting = "Hey there!";\n\nlet greeter2: Greeter2 = new greeterMaker();\nconsole.log(greeter2.greet());\n\n// 把类当做接口使用\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = { x: 1, y: 2, z: 3 };\n\n// 参数属性\nclass Octopus {\n    readonly numberOfLegs: number = 8;\n    \n    constructor(readonly name: string) {\n        // 参数属性通过给构造函数参数前面添加一个访问限定符来声明\n    }\n}\n\nlet dad = new Octopus("Man with the 8 strong legs");\nconsole.log(dad.name);\n\n// 等价于\nclass Octopus2 {\n    readonly numberOfLegs: number = 8;\n    readonly name: string;\n    \n    constructor(theName: string) {\n        this.name = theName;\n    }\n}'
                }
            ]
        },
        {
            title: '泛型',
            items: [
                {
                    title: '泛型函数和接口',
                    description: '泛型的基本使用',
                    code: '// 泛型函数\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output = identity<string>("myString");\nlet output2 = identity("myString"); // 类型推论\n\n// 使用泛型变量\nfunction loggingIdentity<T>(arg: T[]): T[] {\n    console.log(arg.length);\n    return arg;\n}\n\n// 或者\nfunction loggingIdentity2<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);\n    return arg;\n}\n\n// 泛型类型\nlet myIdentity: <T>(arg: T) => T = identity;\n\n// 使用带有调用签名的对象字面量来定义泛型函数\nlet myIdentity2: { <T>(arg: T): T } = identity;\n\n// 泛型接口\ninterface GenericIdentityFn {\n    <T>(arg: T): T;\n}\n\nlet myIdentity3: GenericIdentityFn = identity;\n\n// 把泛型参数当作整个接口的一个参数\ninterface GenericIdentityFn2<T> {\n    (arg: T): T;\n}\n\nlet myIdentity4: GenericIdentityFn2<number> = identity;\n\n// 泛型类\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n    return x + y;\n};\n\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = "";\nstringNumeric.add = function (x, y) {\n    return x + y;\n};\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, "test"));'
                },
                {
                    title: '泛型约束',
                    description: '对泛型参数的约束',
                    code: '// 泛型约束\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity3<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\n// loggingIdentity3(3); // Error, number doesn\'t have a .length property\nloggingIdentity3({ length: 10, value: 3 });\n\n// 在泛型约束中使用类型参数\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, "a"); // okay\n// getProperty(x, "m"); // error: Argument of type \'m\' isn\'t assignable to \'a\' | \'b\' | \'c\' | \'d\'.\n\n// 在泛型里使用类类型\nfunction create<T>(c: { new (): T }): T {\n    return new c();\n}\n\n// 更高级的例子\nclass BeeKeeper {\n    hasMask: boolean;\n}\n\nclass ZooKeeper {\n    nametag: string;\n}\n\nclass Animal4 {\n    numLegs: number;\n}\n\nclass Bee extends Animal4 {\n    keeper: BeeKeeper;\n}\n\nclass Lion extends Animal4 {\n    keeper: ZooKeeper;\n}\n\nfunction createInstance<A extends Animal4>(c: new () => A): A {\n    return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n\n// 条件类型\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype A = NonNullable<string | number | undefined>; // string | number\ntype B = NonNullable<string[] | null | undefined>; // string[]\n\n// 映射类型\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n\ninterface Person {\n    name: string;\n    age: number;\n}'
                }
            ]
        },
        {
            title: '高级类型',
            items: [
                {
                    title: '索引类型',
                    description: 'keyof和索引访问操作符',
                    code: '// keyof操作符\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n\ntype K1 = keyof Person; // "name" | "age" | "location"\ntype K2 = keyof Person[]; // "length" | "toString" | "pop" | "push" | "concat" | "join"\ntype K3 = keyof { [x: string]: Person }; // string | number\n\n// 索引访问操作符\ntype P1 = Person["name"]; // string\ntype P2 = Person["name" | "age"]; // string | number\ntype P3 = string["charAt"]; // (pos: number) => string\ntype P4 = string[]["push"]; // (...items: string[]) => number\ntype P5 = string[][0]; // string\n\n// 索引类型查询和索引访问\nfunction pluck<T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {\n    return propertyNames.map(n => o[n]);\n}\n\ninterface Car {\n    manufacturer: string;\n    model: string;\n    year: number;\n}\n\nlet taxi: Car = {\n    manufacturer: \'Toyota\',\n    model: \'Camry\',\n    year: 2014\n};\n\n// Manufacturer and model are both of type string,\n// so we can pluck them both into a typed string array\nlet makeAndModel: string[] = pluck(taxi, [\'manufacturer\', \'model\']);\n\n// If we try to pluck model and year, we get an\n// array of a union type: (string | number)[]\nlet modelYear = pluck(taxi, [\'model\', \'year\']);\n\n// 索引类型和字符串索引签名\ninterface Map<T> {\n    [key: string]: T;\n}\n\nlet keys: keyof Map<number>; // string | number\nlet value: Map<number>[\'foo\']; // number'
                },
                {
                    title: '映射类型',
                    description: '从旧类型创建新类型',
                    code: '// 映射类型\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\ntype PersonPartial = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n\n// 使用\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet person: PersonPartial = {\n    name: "Alice"\n    // age是可选的\n};\n\nlet readonlyPerson: ReadonlyPerson = {\n    name: "Bob",\n    age: 25\n};\n// readonlyPerson.name = "Charlie"; // Error: Cannot assign to \'name\' because it is a read-only property\n\n// 更复杂的映射类型\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\ntype PersonName = Pick<Person, \'name\'>;\ntype ThreeStringProps = Record<\'prop1\' | \'prop2\' | \'prop3\', string>;\n\n// 条件映射类型\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype Exclude<T, U> = T extends U ? never : T;\ntype Extract<T, U> = T extends U ? T : never;\n\ntype T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"\ntype T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n\ntype T3 = Extract<"a" | "b" | "c", "a" | "f">; // "a"\ntype T4 = Extract<string | number | (() => void), Function>; // () => void\n\n// 预定义的有条件类型\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n\ntype T5 = ReturnType<() => string>; // string\ntype T6 = ReturnType<(s: string) => void>; // void\ntype T7 = ReturnType<<T>() => T>; // {}\ntype T8 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]'
                },
                {
                    title: '条件类型',
                    description: '基于条件的类型选择',
                    code: '// 条件类型\ntype TypeName<T> = T extends string\n    ? "string"\n    : T extends number\n    ? "number"\n    : T extends boolean\n    ? "boolean"\n    : T extends undefined\n    ? "undefined"\n    : T extends Function\n    ? "function"\n    : "object";\n\ntype T0 = TypeName<string>; // "string"\ntype T1 = TypeName<"a">; // "string"\ntype T2 = TypeName<true>; // "boolean"\ntype T3 = TypeName<() => void>; // "function"\ntype T4 = TypeName<string[]>; // "object"\n\n// 分布式条件类型\ntype T5 = TypeName<string | (() => void)>; // "string" | "function"\ntype T6 = TypeName<string | string[] | undefined>; // "string" | "object" | "undefined"\n\n// 条件类型中的类型推断\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n\ntype T7 = ReturnType<() => string>; // string\ntype T8 = ReturnType<(s: string) => void>; // void\n\n// 更复杂的推断\ntype Unpacked<T> = T extends (infer U)[]\n    ? U\n    : T extends (...args: any[]) => infer U\n    ? U\n    : T extends Promise<infer U>\n    ? U\n    : T;\n\ntype T9 = Unpacked<string[]>; // string\ntype T10 = Unpacked<() => string>; // string\ntype T11 = Unpacked<Promise<string>>; // string\ntype T12 = Unpacked<Promise<string>[]>; // Promise<string>\ntype T13 = Unpacked<Unpacked<Promise<string>[]>>; // string\n\n// 预定义的条件类型\ntype Exclude<T, U> = T extends U ? never : T;\ntype Extract<T, U> = T extends U ? T : never;\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\ntype InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\n\n// 使用示例\ntype T14 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"\ntype T15 = Extract<"a" | "b" | "c", "a" | "f">; // "a"\ntype T16 = NonNullable<string | number | undefined>; // string | number\ntype T17 = ReturnType<(s: string) => void>; // void\ntype T18 = InstanceType<typeof Date>; // Date'
                }
            ]
        },
        {
            title: '模块',
            items: [
                {
                    title: '模块导出和导入',
                    description: 'ES6模块语法',
                    code: '// 导出\n// math.ts\nexport function add(x: number, y: number): number {\n    return x + y;\n}\n\nexport function subtract(x: number, y: number): number {\n    return x - y;\n}\n\nexport const PI = 3.14159;\n\n// 默认导出\nexport default function multiply(x: number, y: number): number {\n    return x * y;\n}\n\n// 重新导出\nexport { add as addition } from "./math";\nexport * from "./math";\n\n// 导入\n// app.ts\nimport { add, subtract, PI } from "./math";\nimport multiply from "./math"; // 默认导入\nimport * as math from "./math"; // 命名空间导入\nimport { add as addition } from "./math"; // 重命名导入\n\nconsole.log(add(1, 2));\nconsole.log(multiply(3, 4));\nconsole.log(math.PI);\n\n// 动态导入\nasync function loadMath() {\n    const mathModule = await import("./math");\n    return mathModule.add(1, 2);\n}\n\n// 类型导入\n// types.ts\nexport interface User {\n    name: string;\n    age: number;\n}\n\nexport type UserID = string | number;\n\n// app.ts\nimport type { User, UserID } from "./types";\n\nconst user: User = {\n    name: "Alice",\n    age: 25\n};\n\nconst id: UserID = "user123";\n\n// 仅导入类型\nimport { type User as UserType } from "./types";'
                },
                {
                    title: '命名空间',
                    description: 'TypeScript命名空间',
                    code: '// 命名空间\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n\n// 使用命名空间\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators["ZIP code"] = new Validation.ZipCodeValidator();\nvalidators["Letters only"] = new Validation.LettersOnlyValidator();\n\n// 别名\nimport q = Validation;\nlet zipValidator = new q.ZipCodeValidator();\n\n// 多文件命名空间\n// Validation.ts\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n}\n\n// LettersOnlyValidator.ts\n/// <reference path="Validation.ts" />\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}\n\n// 嵌套命名空间\nnamespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();'
                },
                {
                    title: '模块解析',
                    description: '模块解析策略和配置',
                    code: '// tsconfig.json 模块解析配置\n{\n  "compilerOptions": {\n    "moduleResolution": "node", // 或 "classic"\n    "baseUrl": "./",\n    "paths": {\n      "@/*": ["src/*"],\n      "@components/*": ["src/components/*"],\n      "@utils/*": ["src/utils/*"]\n    },\n    "typeRoots": ["./typings", "./node_modules/@types"],\n    "types": ["node", "jest"],\n    "esModuleInterop": true,\n    "allowSyntheticDefaultImports": true\n  }\n}\n\n// 路径映射使用\nimport { Button } from "@components/Button";\nimport { formatDate } from "@utils/date";\n\n// 声明文件\n// types/global.d.ts\ndeclare global {\n    interface Window {\n        myGlobalFunction: () => void;\n    }\n}\n\ndeclare module "*.vue" {\n    import { DefineComponent } from "vue";\n    const component: DefineComponent<{}, {}, any>;\n    export default component;\n}\n\ndeclare module "*.module.css" {\n    const classes: { [key: string]: string };\n    export default classes;\n}\n\n// 环境模块\ndeclare module "my-library" {\n    export function doSomething(): void;\n    export default function defaultFunction(): string;\n}\n\n// 使用\nimport myLib, { doSomething } from "my-library";\n\n// UMD模块\ndeclare namespace MyLibrary {\n    function makeGreeting(s: string): string;\n    let numberOfGreetings: number;\n}\n\n// 可以作为模块使用\nimport * as myLib from "my-library";\nlet greeting = myLib.makeGreeting("hello");\n\n// 也可以作为全局变量使用\nlet greeting2 = MyLibrary.makeGreeting("hello");'
                }
            ]
        }
    ]
};

// 导出数据
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TYPESCRIPT_CHEATSHEET;
} else if (typeof window !== 'undefined') {
    window.TYPESCRIPT_CHEATSHEET = TYPESCRIPT_CHEATSHEET;
}